
- Explain how the arguments make it all the way from user program invoking
  execv until they turn into main's argc, and argv for the target program

Without loss of generality, we can look at how the shell user programs calls
execv. Once the shell splits the argmuments into a null terminated char** array,
it calls execv() with the executable name as the first argument, followed by all
the arguments. This function is defined in sys.h and will make a system call by
setting up the %ecx and %edx registers and then performing an interrupt. The
interrupt goes to the IDT and then to the syscall handler in syscall.cc.

In the system call handler, the registers are cast to a char* pointer, in the
case of the name, and a char** pointer, in the case of the arguments. It then
proceeds to copy all the arguments to kernel space and put them into a simple
queue. It then calls Process::execv() with the program name, a pointer to the
simple queue, and the number of arguments.

In Process::execv, we find the executable by getting it from it from the
filesystem. We then clear the addressSpace, set the stack to 0xfffffff0, and
then proceed to copy over the arguments from the simple queue in kernel memory
to a place in user memory (arbitrarily defined at 0xffff0000). Once the
arguments are in user memory (so they can be read by the user program) it sets
up the first value on the stack to be the argument count, and the second entry
as a pointer to the char** array that is in user memory; exactly what the
running program expect when it executes main.

- My implementation of execv in syscall.cc is not secure. Show a user
  program that can read any memory address by exploiting my bad code

- How would change the code to protect against this attack

- What do we need to change in order to implement input and output
  redirection and pipes in the shell?

